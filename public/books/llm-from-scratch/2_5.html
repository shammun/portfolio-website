<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>LLM Vocabulary & Token Mapper</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@500;600&display=swap');

    :root {
      --bg-gradient: linear-gradient(135deg, #fafbff 0%, #f5f7ff 100%);
      --token-word-bg: #fff7ed;
      --token-word-border: #fdba74;
      --token-word-text: #c2410c;
      --token-punct-bg: #f3e8ff;
      --token-punct-border: #c4b5fd;
      --token-punct-text: #7c3aed;
      --highlight-teal: #14b8a6;
    }

    body {
      font-family: 'Inter', sans-serif;
      background: var(--bg-gradient);
      color: #1e293b;
      min-height: 100vh;
    }

    .mono {
      font-family: 'JetBrains Mono', monospace;
    }

    .card {
      background: white;
      border-radius: 16px;
      box-shadow: 0 4px 16px rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(226, 232, 240, 0.8);
    }

    .token-pill {
      display: inline-block;
      padding: 4px 10px;
      border-radius: 8px;
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
      margin: 3px;
      border: 1px solid transparent;
      user-select: none;
    }

    .token-pill:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
    }

    .token-pill.word {
      background-color: var(--token-word-bg);
      border-color: var(--token-word-border);
      color: var(--token-word-text);
    }

    .token-pill.punctuation {
      background-color: var(--token-punct-bg);
      border-color: var(--token-punct-border);
      color: var(--token-punct-text);
    }

    .token-pill.active {
      box-shadow: 0 0 0 3px var(--highlight-teal);
      transform: scale(1.05);
    }

    .vocab-entry {
      display: flex;
      justify-content: space-between;
      padding: 8px 16px;
      border-bottom: 1px solid #f1f5f9;
      transition: all 0.2s;
      cursor: pointer;
    }

    .vocab-entry:hover {
      background-color: #f8fafc;
    }

    .vocab-entry.active {
      background-color: #f0fdfa;
      border-left: 4px solid var(--highlight-teal);
    }

    .callout {
      background: #eff6ff;
      border-left: 4px solid #3b82f6;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 0.875rem;
      color: #1e40af;
    }

    .step-node {
      display: flex;
      flex-direction: column;
      align-items: center;
      text-align: center;
      flex: 1;
    }

    .step-circle {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #6366f1;
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      margin-bottom: 8px;
      position: relative;
      z-index: 2;
    }

    .pipeline-connector {
      position: absolute;
      top: 16px;
      left: 50%;
      width: 100%;
      height: 2px;
      background: #e2e8f0;
      z-index: 1;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-build {
      animation: fadeIn 0.3s ease-out forwards;
    }

    ::-webkit-scrollbar {
      width: 6px;
    }

    ::-webkit-scrollbar-track {
      background: #f1f5f9;
    }

    ::-webkit-scrollbar-thumb {
      background: #cbd5e1;
      border-radius: 10px;
    }
  </style>
</head>

<body class="p-4 md:p-8">
  <div class="max-w-6xl mx-auto">
    <!-- Header & Flow -->
    <header class="mb-8 text-center">
      <h1 class="text-3xl font-bold text-slate-800 mb-2">LLM Vocabulary & Token Mapper</h1>
      <p class="text-slate-500 max-w-2xl mx-auto">
        Discover how Large Language Models transform human text into numerical IDs through tokenization and vocabulary
        building.
      </p>
    </header>

    <!-- Pipeline Diagram -->
    <div class="card p-6 mb-8 overflow-hidden">
      <div class="flex relative items-start">
        <div class="step-node">
          <div class="step-circle">1</div>
          <div class="pipeline-connector"></div>
          <span class="text-xs font-semibold uppercase text-slate-400">Raw Text</span>
        </div>
        <div class="step-node">
          <div class="step-circle">2</div>
          <div class="pipeline-connector"></div>
          <span class="text-xs font-semibold uppercase text-slate-400">Tokenize</span>
        </div>
        <div class="step-node">
          <div class="step-circle">3</div>
          <div class="pipeline-connector"></div>
          <span class="text-xs font-semibold uppercase text-slate-400">Build Vocab</span>
        </div>
        <div class="step-node">
          <div class="step-circle">4</div>
          <div class="pipeline-connector"></div>
          <span class="text-xs font-semibold uppercase text-slate-400">Encode</span>
        </div>
        <div class="step-node">
          <div class="step-circle">5</div>
          <span class="text-xs font-semibold uppercase text-slate-400">Numbers (IDs)</span>
        </div>
      </div>
    </div>

    <!-- Section 1: Input -->
    <div class="card p-6 mb-8">
      <h2 class="text-xs font-semibold text-slate-500 uppercase tracking-wider mb-4">Step 1: Input Text</h2>
      <textarea id="inputText" rows="3"
        class="w-full p-4 border border-slate-200 rounded-xl focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500 outline-none transition-all resize-none text-slate-700"
        placeholder="Type something to tokenize..."></textarea>
      <div class="flex gap-3 mt-4">
        <button id="btnBuild"
          class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold px-6 py-2.5 rounded-lg transition-colors flex items-center gap-2">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none"
            stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z" />
            <path d="M19 3v4" />
            <path d="M21 5h-4" />
          </svg>
          Build Vocabulary
        </button>
        <button id="btnClear"
          class="bg-slate-100 hover:bg-slate-200 text-slate-600 font-semibold px-6 py-2.5 rounded-lg transition-colors">
          Clear
        </button>
      </div>
    </div>

    <!-- Middle Grid -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mb-8">
      <!-- Section 2: Tokenization -->
      <div class="card flex flex-col h-[500px]">
        <div class="p-6 border-b border-slate-100 flex justify-between items-center">
          <h2 class="text-xs font-semibold text-slate-500 uppercase tracking-wider">Tokenized Text</h2>
          <span id="tokenCount" class="text-xs font-bold px-2 py-1 bg-slate-100 rounded text-slate-500">0 Tokens</span>
        </div>
        <div id="tokenDisplay" class="p-6 flex-1 overflow-y-auto content-start">
          <p class="text-slate-400 italic text-center mt-20">Click "Build Vocabulary" to see tokens</p>
        </div>
        <div class="p-4 bg-slate-50 border-t border-slate-100">
          <div class="callout">
            <strong>‚úÇÔ∏è Punctuation matters:</strong> Notice that commas, periods, and quotes are separate tokens. This
            helps the model learn grammar.
          </div>
        </div>
      </div>

      <!-- Section 3: Vocabulary -->
      <div class="card flex flex-col h-[500px]">
        <div class="p-6 border-b border-slate-100 flex justify-between items-center">
          <h2 class="text-xs font-semibold text-slate-500 uppercase tracking-wider">Vocabulary Dictionary (stoi)</h2>
          <span id="vocabSize" class="text-xs font-bold px-2 py-1 bg-indigo-100 rounded text-indigo-600">0 Unique</span>
        </div>
        <div id="vocabList" class="flex-1 overflow-y-auto mono text-sm">
          <div class="p-6 text-slate-400 italic text-center mt-20">Dictionary will appear here</div>
        </div>
        <div class="p-4 bg-slate-50 border-t border-slate-100">
          <div class="callout">
            <strong>üìö Alphabetical Order:</strong> Sorting ensures consistent ID assignment across different sessions.
          </div>
        </div>
      </div>
    </div>

    <!-- Section 4: Lookup Tool -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-8 mb-8">
      <div class="card p-6">
        <h2 class="text-xs font-semibold text-slate-500 uppercase tracking-wider mb-4">Encode: Token ‚Üí ID</h2>
        <div class="space-y-4">
          <input id="encodeInput" type="text" class="w-full p-3 border border-slate-200 rounded-lg mono text-sm"
            placeholder="Enter a token (e.g. Hello)">
          <div id="encodeResult"
            class="h-12 flex items-center px-4 bg-indigo-50 rounded-lg text-indigo-700 font-bold mono">
            ID: --
          </div>
        </div>
      </div>
      <div class="card p-6">
        <h2 class="text-xs font-semibold text-slate-500 uppercase tracking-wider mb-4">Decode: ID ‚Üí Token</h2>
        <div class="space-y-4">
          <input id="decodeInput" type="number" class="w-full p-3 border border-slate-200 rounded-lg mono text-sm"
            placeholder="Enter an ID (e.g. 5)">
          <div id="decodeResult"
            class="h-12 flex items-center px-4 bg-purple-50 rounded-lg text-purple-700 font-bold mono">
            Token: --
          </div>
        </div>
      </div>
    </div>

    <!-- Section 5: Live Action -->
    <div class="card p-6 mb-8">
      <h2 class="text-xs font-semibold text-slate-500 uppercase tracking-wider mb-6 text-center">Encode & Decode in
        Action</h2>
      <div class="grid grid-cols-1 md:grid-cols-3 items-center gap-4">
        <div class="p-4 bg-slate-50 rounded-xl">
          <div class="text-[10px] font-bold text-slate-400 uppercase mb-2">Original Text</div>
          <div id="liveOriginal" class="text-sm text-slate-600 line-clamp-3">...</div>
        </div>

        <div class="flex flex-col items-center gap-2">
          <div class="text-[10px] font-bold text-indigo-400 uppercase">Numerical IDs</div>
          <div
            class="w-full p-3 bg-indigo-600 rounded-lg text-white mono text-xs break-all text-center min-h-[60px] flex items-center justify-center"
            id="liveIds">
            []
          </div>
          <div class="text-[10px] font-bold text-purple-400 uppercase mt-2">Reconstructed</div>
        </div>

        <div class="p-4 bg-slate-50 rounded-xl">
          <div class="text-[10px] font-bold text-slate-400 uppercase mb-2">Model Output</div>
          <div id="liveReconstructed" class="text-sm text-slate-600 line-clamp-3">...</div>
        </div>
      </div>
      <div class="mt-6">
        <div class="callout border-indigo-500 bg-indigo-50 text-indigo-900">
          <strong>üîÑ Two-way street:</strong> Encoding converts text to numbers for the model. Decoding converts the
          model's numerical output back to readable text. Both directions use the same vocabulary!
        </div>
      </div>
    </div>

    <footer class="text-center text-slate-400 text-xs pb-12">
      Educational Interactive Visualization ‚Ä¢ Understanding LLM Foundations
    </footer>
  </div>

  <script>
    // Constants & State
    const DEFAULT_TEXT = `"It's the last he painted, you know," Mrs. Gisburn said with pardonable pride.`;
    let state = {
      tokens: [],
      strToInt: {},
      intToStr: {},
      vocabSize: 0,
      activeToken: null,
      activeId: null
    };

    // DOM Elements
    const inputText = document.getElementById('inputText');
    const btnBuild = document.getElementById('btnBuild');
    const btnClear = document.getElementById('btnClear');
    const tokenDisplay = document.getElementById('tokenDisplay');
    const vocabList = document.getElementById('vocabList');
    const tokenCountEl = document.getElementById('tokenCount');
    const vocabSizeEl = document.getElementById('vocabSize');
    const encodeInput = document.getElementById('encodeInput');
    const encodeResult = document.getElementById('encodeResult');
    const decodeInput = document.getElementById('decodeInput');
    const decodeResult = document.getElementById('decodeResult');
    const liveOriginal = document.getElementById('liveOriginal');
    const liveIds = document.getElementById('liveIds');
    const liveReconstructed = document.getElementById('liveReconstructed');

    // Initialization
    window.onload = () => {
      inputText.value = DEFAULT_TEXT;
      handleBuild();
    };

    // Core Logic
    function tokenize(text) {
      // Split on punctuation and whitespace, keeping delimiters
      const pattern = /([,.:;?_!"()'']|--|\s)/;
      let tokens = text.split(pattern);
      // Remove empty strings and whitespace-only tokens
      return tokens.filter(token => token.trim() !== '');
    }

    function buildVocabulary(tokens) {
      const uniqueTokens = [...new Set(tokens)].sort();
      const strToInt = {};
      const intToStr = {};

      uniqueTokens.forEach((token, index) => {
        strToInt[token] = index;
        intToStr[index] = token;
      });

      return { strToInt, intToStr, vocabSize: uniqueTokens.length };
    }

    function encode(tokens, strToInt) {
      return tokens.map(token => strToInt[token]);
    }

    function decode(ids, intToStr) {
      const tokens = ids.map(id => intToStr[id]);
      // Logic to join tokens with sensible spacing
      let text = "";
      tokens.forEach((token, i) => {
        const isPunct = /[,.:;?_!"()'']|--/.test(token);
        if (i === 0 || isPunct) {
          text += token;
        } else {
          const prevWasPunct = /["'']/.test(tokens[i - 1]);
          text += (prevWasPunct ? "" : " ") + token;
        }
      });
      return text;
    }

    // UI Handlers
    async function handleBuild() {
      const text = inputText.value.trim();
      if (!text) return;

      // Reset UI
      tokenDisplay.innerHTML = '';
      vocabList.innerHTML = '';

      const tokens = tokenize(text);
      const vocab = buildVocabulary(tokens);

      state.tokens = tokens;
      state.strToInt = vocab.strToInt;
      state.intToStr = vocab.intToStr;
      state.vocabSize = vocab.vocabSize;

      tokenCountEl.innerText = `${tokens.length} Tokens`;
      vocabSizeEl.innerText = `${vocab.vocabSize} Unique`;

      // Animate building tokens
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const isPunct = /[,.:;?_!"()'']|--/.test(token);
        const pill = document.createElement('span');
        pill.className = `token-pill animate-build ${isPunct ? 'punctuation' : 'word'}`;
        pill.innerText = token;
        pill.dataset.index = i;
        pill.dataset.token = token;
        pill.onclick = () => highlightToken(token);
        tokenDisplay.appendChild(pill);
        if (i < 20) await new Promise(r => setTimeout(r, 20)); // Subtle cascade
      }

      // Populate Vocab List
      const sortedTokens = Object.keys(state.strToInt).sort();
      sortedTokens.forEach(token => {
        const id = state.strToInt[token];
        const entry = document.createElement('div');
        entry.className = 'vocab-entry animate-build';
        entry.dataset.token = token;
        entry.dataset.id = id;
        entry.innerHTML = `
                    <span class="text-slate-600">"${token}"</span>
                    <span class="text-indigo-500 font-bold">${id}</span>
                `;
        entry.onclick = () => highlightToken(token);
        vocabList.appendChild(entry);
      });

      updateLiveDemo();
    }

    function highlightToken(token) {
      const id = state.strToInt[token];

      // Highlight pills
      document.querySelectorAll('.token-pill').forEach(p => {
        p.classList.toggle('active', p.dataset.token === token);
      });

      // Highlight vocab entries
      document.querySelectorAll('.vocab-entry').forEach(e => {
        e.classList.toggle('active', e.dataset.token === token);
        if (e.dataset.token === token) {
          e.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
      });

      // Update Lookup Tools
      encodeInput.value = token;
      encodeResult.innerText = `ID: ${id}`;
      decodeInput.value = id;
      decodeResult.innerText = `Token: "${token}"`;
    }

    function updateLiveDemo() {
      const text = inputText.value;
      const ids = encode(state.tokens, state.strToInt);
      const reconstructed = decode(ids, state.intToStr);

      liveOriginal.innerText = text;
      liveIds.innerText = `[${ids.join(', ')}]`;
      liveReconstructed.innerText = reconstructed;
    }

    // Event Listeners
    btnBuild.onclick = handleBuild;

    btnClear.onclick = () => {
      inputText.value = '';
      tokenDisplay.innerHTML = '<p class="text-slate-400 italic text-center mt-20">Click "Build Vocabulary" to see tokens</p>';
      vocabList.innerHTML = '<div class="p-6 text-slate-400 italic text-center mt-20">Dictionary will appear here</div>';
      tokenCountEl.innerText = '0 Tokens';
      vocabSizeEl.innerText = '0 Unique';
      encodeInput.value = '';
      encodeResult.innerText = 'ID: --';
      decodeInput.value = '';
      decodeResult.innerText = 'Token: --';
      liveOriginal.innerText = '...';
      liveIds.innerText = '[]';
      liveReconstructed.innerText = '...';
    };

    encodeInput.oninput = (e) => {
      const val = e.target.value;
      if (state.strToInt[val] !== undefined) {
        highlightToken(val);
      } else {
        encodeResult.innerText = 'Token not found';
      }
    };

    decodeInput.oninput = (e) => {
      const val = parseInt(e.target.value);
      if (state.intToStr[val] !== undefined) {
        highlightToken(state.intToStr[val]);
      } else {
        decodeResult.innerText = 'ID not found';
      }
    };

  </script>
</body>

</html>