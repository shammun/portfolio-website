<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multilayer Perceptron Architecture</title>
    <style>
        :root {
            /* Backgrounds */
            --bg-start: #fafbff;
            --bg-end: #f5f7ff;
            --card-bg: #ffffff;

            /* Semantic Colors */
            --input-light: #fef3c7;
            --input-medium: #f97316;
            --input-border: #fdba74;

            --hidden-light: #ede9fe;
            --hidden-medium: #8b5cf6;
            --hidden-dark: #7c3aed;

            --output-light: #ecfdf5;
            --output-medium: #14b8a6;
            --output-dark: #0d9488;

            --text-heading: #1e293b;
            --text-body: #64748b;
            --text-muted: #94a3b8;

            /* Typography */
            --font-main: system-ui, -apple-system, sans-serif;
            --font-math: Georgia, serif;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: var(--font-main);
            background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
            color: var(--text-heading);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .container {
            width: 95%;
            max-width: 1400px;
            margin: 10px auto;
            /* Reduced top margin */
            padding: 0 20px;
            box-sizing: border-box;
        }

        .header {
            text-align: center;
            margin-bottom: 0;
            /* Removed margin completely */
        }

        h1 {
            font-size: 28px;
            font-weight: 700;
            color: var(--text-heading);
            margin: 0 0 8px 0;
        }

        .subtitle {
            font-size: 16px;
            font-weight: 400;
            color: var(--text-body);
            margin: 0;
        }

        /* SVG Container */
        .canvas-container {
            width: 100%;
            background: transparent;
            border-radius: 16px;
            overflow: visible;
            margin-bottom: 0;
            /* Removed bottom margin */
            position: relative;
        }

        svg {
            width: 100%;
            height: auto;
            display: block;
            user-select: none;
        }

        /* Controls */
        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 20px;
            /* Reduced margin */
            margin-top: 5px;
            /* Slight top margin */
            align-items: center;
            flex-wrap: wrap;
        }

        button {
            background-color: var(--card-bg);
            border: 1px solid var(--hidden-medium);
            color: var(--hidden-medium);
            padding: 10px 24px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: var(--font-main);
            box-shadow: 0 2px 4px rgba(139, 92, 246, 0.1);
        }

        button:hover {
            background-color: var(--hidden-medium);
            color: white;
            box-shadow: 0 4px 12px rgba(139, 92, 246, 0.25);
            transform: translateY(-1px);
        }

        button:active {
            transform: translateY(0);
        }

        .checkbox-wrapper {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-body);
            font-size: 14px;
            cursor: pointer;
        }

        /* Info Panel */
        .info-panel {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 4px 20px rgba(99, 102, 241, 0.12);
            width: 100%;
            min-height: 200px;
            box-sizing: border-box;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            transition: opacity 0.3s ease;
        }

        @media (max-width: 768px) {
            .info-panel {
                grid-template-columns: 1fr;
            }
        }

        .panel-section h3 {
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-body);
            margin-top: 0;
            border-bottom: 1px solid #e2e8f0;
            padding-bottom: 10px;
            margin-bottom: 15px;
        }

        .code-block {
            background-color: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 13px;
            color: #334155;
            border-left: 4px solid var(--hidden-medium);
            white-space: pre-wrap;
            line-height: 1.5;
        }

        .math-block {
            font-family: var(--font-math);
            font-size: 18px;
            color: var(--text-heading);
            margin: 10px 0;
        }

        .math-var {
            font-style: italic;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 13px;
            font-size: 12px;
            font-weight: 500;
            margin-right: 8px;
        }

        .badge-input {
            background: var(--input-light);
            color: #c2410c;
        }

        .badge-hidden {
            background: var(--hidden-light);
            color: var(--hidden-dark);
        }

        .badge-output {
            background: var(--output-light);
            color: var(--output-dark);
        }

        /* Animation Classes */
        .pulse {
            animation: pulse-animation 2s infinite;
        }

        @keyframes pulse-animation {
            0% {
                opacity: 0.4;
                r: 4;
            }

            50% {
                opacity: 1;
                r: 6;
            }

            100% {
                opacity: 0.4;
                r: 4;
            }
        }

        /* SVG Interactive Elements */
        .layer-card {
            cursor: pointer;
            transition: filter 0.2s;
        }

        .layer-card:hover {
            filter: brightness(0.98);
        }

        .layer-card.active rect {
            stroke: var(--hidden-medium);
            stroke-width: 2px;
        }

        .node-circle {
            transition: r 0.2s, stroke-width 0.2s;
            cursor: crosshair;
        }

        .node-circle:hover {
            r: 10;
            stroke-width: 3;
        }

        .connection-path {
            transition: stroke-opacity 0.2s, stroke-width 0.2s, stroke 0.2s;
        }

        .connection-path.highlighted {
            stroke-opacity: 0.9;
            stroke-width: 2;
            stroke: var(--hidden-medium);
        }

        .connection-path.faded {
            stroke-opacity: 0.05;
        }
    </style>
</head>

<body>

    <div class="container">
        <div class="header">
            <h1>Multilayer Perceptron Architecture</h1>
            <p class="subtitle">50 inputs → 30 nodes → 20 nodes → 3 outputs • Interactive Visualization</p>
        </div>

        <div class="canvas-container">
            <!-- Reduced viewBox height from 600 to 380 to crop whitespace -->
            <svg id="network-svg" viewBox="0 0 1400 380" preserveAspectRatio="xMidYMid meet">
                <defs>
                    <!-- Shadow Filter -->
                    <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                        <feDropShadow dx="0" dy="4" stdDeviation="8" flood-color="#6366f1" flood-opacity="0.12" />
                    </filter>

                    <!-- Inner Shadow for Graphs -->
                    <filter id="inner-shadow">
                        <feComponentTransfer in=SourceAlpha>
                            <feFuncA type="table" tableValues="1 0" />
                        </feComponentTransfer>
                        <feGaussianBlur stdDeviation="3" />
                        <feOffset dx="0" dy="2" result="offsetblur" />
                        <feFlood flood-color="rgb(0, 0, 0)" flood-opacity="0.1" />
                        <feComposite in2="offsetblur" operator="in" />
                        <feComposite in2="SourceAlpha" operator="in" />
                        <feMerge>
                            <feMergeNode in="SourceGraphic" />
                            <feMergeNode />
                        </feMerge>
                    </filter>

                    <!-- Gradients -->
                    <linearGradient id="grad-input" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#fef3c7" />
                        <stop offset="100%" style="stop-color:#fcd34d" />
                    </linearGradient>

                    <linearGradient id="grad-hidden" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#c4b5fd" />
                        <stop offset="100%" style="stop-color:#8b5cf6" />
                    </linearGradient>

                    <linearGradient id="grad-output" x1="0%" y1="0%" x2="0%" y2="100%">
                        <stop offset="0%" style="stop-color:#ecfdf5" />
                        <stop offset="100%" style="stop-color:#14b8a6" />
                    </linearGradient>

                    <linearGradient id="grad-relu" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#a78bfa" />
                        <stop offset="100%" style="stop-color:#7c3aed" />
                    </linearGradient>

                    <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                        <polygon points="0 0, 10 3.5, 0 7" fill="#cbd5e1" />
                    </marker>
                </defs>

                <!-- Connections Group (Behind cards) -->
                <g id="connections-layer"></g>

                <!-- Layers Group -->
                <g id="layers-group"></g>

                <!-- Animation Group (On top) -->
                <g id="animation-layer"></g>
            </svg>
        </div>

        <div class="controls">
            <button id="animate-btn">Animate Forward Pass</button>
            <button id="reset-btn">Reset View</button>
            <label class="checkbox-wrapper">
                <input type="checkbox" id="show-params" checked> Show Parameters
            </label>
        </div>

        <div class="info-panel" id="info-panel">
            <div class="panel-section">
                <h3>Component Details</h3>
                <div id="details-content">
                    <p style="color: var(--text-muted); font-style: italic;">Hover over a node to see incoming
                        connections, or a layer card for details.</p>
                </div>
            </div>
            <div class="panel-section">
                <h3>PyTorch Implementation</h3>
                <div id="code-content" class="code-block"># Hover over a layer or node</div>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & Data ---
        const CONFIG = {
            canvasWidth: 1400,
            canvasHeight: 400, // Reduced from 600
            cardWidth: 180,
            cardHeight: 320,
            reluSize: 80,
            colors: {
                input: '#f97316',
                hidden: '#8b5cf6',
                output: '#14b8a6',
                text: '#1e293b',
                connection: '#cbd5e1'
            }
        };

        const LAYERS = [
            {
                id: 'input',
                type: 'Input',
                name: 'Input Layer',
                nodes: 50,
                visualNodes: 8,
                x: 50,
                y: 30, // Shifted up from 140
                color: CONFIG.colors.input,
                bgFill: '#fff7ed',
                badgeClass: 'badge-input',
                desc: "Raw input features fed into the network. Each node represents one feature.",
                code: "# Input features (Batch Size, 50)\nx = torch.randn(32, 50)",
                math: "X &in; &#8477;<sup>50</sup>"
            },
            {
                id: 'layer1',
                type: 'Linear',
                name: 'Hidden Layer 1',
                nodes: 30,
                visualNodes: 7,
                prevNodes: 50,
                x: 400,
                y: 30, // Shifted up from 140
                color: CONFIG.colors.hidden,
                bgFill: '#f5f3ff',
                badgeClass: 'badge-hidden',
                desc: "First dense layer. Fully connected to Input.",
                code: "self.layer1 = nn.Linear(50, 30)",
                math: "h<sub>1</sub> = XW<sub>1</sub><sup>T</sup> + b<sub>1</sub>"
            },
            {
                id: 'relu1',
                type: 'ReLU',
                name: 'Activation',
                x: 630,
                y: 150, // Shifted up from 260
                color: CONFIG.colors.hidden,
                desc: "ReLU applied element-wise to Hidden Layer 1 outputs.",
                code: "x = F.relu(self.layer1(x))",
                math: "f(x) = max(0, x)"
            },
            {
                id: 'layer2',
                type: 'Linear',
                name: 'Hidden Layer 2',
                nodes: 20,
                visualNodes: 6,
                prevNodes: 30,
                x: 760,
                y: 30, // Shifted up from 140
                color: CONFIG.colors.hidden,
                bgFill: '#f5f3ff',
                badgeClass: 'badge-hidden',
                desc: "Second dense layer. Fully connected to Hidden Layer 1.",
                code: "self.layer2 = nn.Linear(30, 20)",
                math: "h<sub>2</sub> = a<sub>1</sub>W<sub>2</sub><sup>T</sup> + b<sub>2</sub>"
            },
            {
                id: 'relu2',
                type: 'ReLU',
                name: 'Activation',
                x: 990,
                y: 150, // Shifted up from 260
                color: CONFIG.colors.hidden,
                desc: "ReLU applied element-wise to Hidden Layer 2 outputs.",
                code: "x = F.relu(self.layer2(x))",
                math: "f(x) = max(0, x)"
            },
            {
                id: 'output',
                type: 'Linear',
                name: 'Output Layer',
                nodes: 3,
                visualNodes: 3,
                prevNodes: 20,
                x: 1120,
                y: 30, // Shifted up from 140
                color: CONFIG.colors.output,
                bgFill: '#ecfdf5',
                badgeClass: 'badge-output',
                desc: "Final projection to class scores (Logits).",
                code: "self.head = nn.Linear(20, 3)",
                math: "y = h<sub>2</sub>W<sub>out</sub><sup>T</sup> + b<sub>out</sub>"
            }
        ];

        // --- Visualization Engine ---
        class NetworkViz {
            constructor() {
                this.svg = document.getElementById('network-svg');
                this.layersGroup = document.getElementById('layers-group');
                this.connectionsGroup = document.getElementById('connections-layer');
                this.animationLayer = document.getElementById('animation-layer');
                this.showParams = true;
                this.isAnimating = false;

                this.nodePositions = {}; // Store coordinates {layerId: [{x,y, isReal}, ...]}
                this.init();
            }

            init() {
                this.drawLayers();
                this.drawConnections();
            }

            calculateParams(inNodes, outNodes) {
                return (inNodes * outNodes) + outNodes;
            }

            drawLayers() {
                this.layersGroup.innerHTML = ''; // Clear

                LAYERS.forEach(layer => {
                    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                    g.setAttribute("class", "layer-card");
                    g.setAttribute("id", `card-${layer.id}`);
                    // Only linear layers have 'visual nodes' that trigger connection highlighting
                    // We keep card click for general info
                    g.onclick = (e) => {
                        // Prevent card click if node was clicked
                        if (e.target.tagName !== 'circle') {
                            this.highlightLayer(layer);
                        }
                    };

                    if (layer.type === 'ReLU') {
                        this.drawReLU(g, layer);
                    } else {
                        this.drawLinearLayer(g, layer);
                    }

                    this.layersGroup.appendChild(g);
                });
            }

            drawLinearLayer(group, layer) {
                // Card Background
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", layer.x);
                rect.setAttribute("y", layer.y);
                rect.setAttribute("width", CONFIG.cardWidth);
                rect.setAttribute("height", CONFIG.cardHeight);
                rect.setAttribute("rx", 16);
                rect.setAttribute("fill", "white");
                rect.setAttribute("filter", "url(#shadow)");
                group.appendChild(rect);

                // Header
                const title = document.createElementNS("http://www.w3.org/2000/svg", "text");
                title.setAttribute("x", layer.x + CONFIG.cardWidth / 2);
                title.setAttribute("y", layer.y + 40);
                title.setAttribute("text-anchor", "middle");
                title.setAttribute("font-weight", "700");
                title.setAttribute("fill", CONFIG.colors.text);
                title.textContent = layer.name;
                group.appendChild(title);

                // Dimension Badge
                const badgeWidth = 80;
                const badgeRect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                badgeRect.setAttribute("x", layer.x + (CONFIG.cardWidth - badgeWidth) / 2);
                badgeRect.setAttribute("y", layer.y + 55);
                badgeRect.setAttribute("width", badgeWidth);
                badgeRect.setAttribute("height", 24);
                badgeRect.setAttribute("rx", 12);
                badgeRect.setAttribute("fill", layer.bgFill);
                group.appendChild(badgeRect);

                const badgeText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                badgeText.setAttribute("x", layer.x + CONFIG.cardWidth / 2);
                badgeText.setAttribute("y", layer.y + 71);
                badgeText.setAttribute("text-anchor", "middle");
                badgeText.setAttribute("font-size", "12");
                badgeText.setAttribute("font-weight", "600");
                badgeText.setAttribute("fill", layer.color);
                badgeText.textContent = `${layer.nodes} Nodes`;
                group.appendChild(badgeText);

                // Params Count
                if (layer.type !== 'Input' && this.showParams) {
                    const params = this.calculateParams(layer.prevNodes, layer.nodes);
                    const paramText = document.createElementNS("http://www.w3.org/2000/svg", "text");
                    paramText.setAttribute("x", layer.x + CONFIG.cardWidth / 2);
                    paramText.setAttribute("y", layer.y + CONFIG.cardHeight - 20);
                    paramText.setAttribute("text-anchor", "middle");
                    paramText.setAttribute("font-size", "11");
                    paramText.setAttribute("fill", "#94a3b8");
                    paramText.setAttribute("class", "param-text");
                    paramText.textContent = `${params.toLocaleString()} Params`;
                    group.appendChild(paramText);
                }

                // Draw Nodes
                const nodeStartY = layer.y + 110;
                const nodeSpaceY = 180;
                const nodeGap = nodeSpaceY / (layer.visualNodes + 1);

                this.nodePositions[layer.id] = [];

                for (let i = 0; i < layer.visualNodes; i++) {
                    // Ellipsis handling
                    if (layer.visualNodes < layer.nodes && i === Math.floor(layer.visualNodes / 2)) {
                        const dots = document.createElementNS("http://www.w3.org/2000/svg", "text");
                        dots.setAttribute("x", layer.x + CONFIG.cardWidth / 2);
                        // Moved dots lower: changed 0.5 to 0.8
                        dots.setAttribute("y", nodeStartY + ((i + 0.8) * nodeGap));
                        dots.setAttribute("text-anchor", "middle");
                        dots.setAttribute("fill", "#cbd5e1");
                        dots.setAttribute("font-weight", "bold");
                        dots.textContent = "...";
                        group.appendChild(dots);
                        // Push null to maintain index alignment for visual convenience, though we won't connect to it
                        // Actually, better to just not push to nodePositions for the ellipsis
                        continue;
                    }

                    const cy = nodeStartY + ((i + 1) * nodeGap);
                    const cx = layer.x + CONFIG.cardWidth / 2;

                    const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                    circle.setAttribute("cx", cx);
                    circle.setAttribute("cy", cy);
                    circle.setAttribute("r", 8);
                    circle.setAttribute("fill", "white");
                    circle.setAttribute("stroke", layer.color);
                    circle.setAttribute("stroke-width", "2");
                    circle.setAttribute("class", "node-circle");

                    // Add Hover Interaction for Nodes
                    // FIX: Pass 'i' (the visual index including skipped ellipsis) to the handler
                    circle.addEventListener('mouseenter', () => this.highlightNodeConnections(layer.id, i));
                    circle.addEventListener('mouseleave', () => this.resetHighlights());

                    group.appendChild(circle);

                    // We store the visual index (i) to map connections
                    this.nodePositions[layer.id].push({ x: cx, y: cy, index: i });
                }
            }

            drawReLU(group, layer) {
                const size = 80;
                const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect.setAttribute("x", layer.x);
                rect.setAttribute("y", layer.y);
                rect.setAttribute("width", size);
                rect.setAttribute("height", size);
                rect.setAttribute("rx", 12);
                rect.setAttribute("fill", "#f5f3ff");
                rect.setAttribute("stroke", "#e2e8f0");
                rect.setAttribute("filter", "url(#inner-shadow)");
                group.appendChild(rect);

                // Graph Axes
                const padding = 15;
                const originX = layer.x + padding;
                const originY = layer.y + size - padding;
                const endX = layer.x + size - padding;
                const endY = layer.y + padding;

                const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                let d = `M ${originX} ${originY - size + 2 * padding} L ${originX} ${originY} L ${endX} ${originY}`;
                const midX = originX + (endX - originX) / 2;
                d += ` M ${originX} ${originY} L ${midX} ${originY} L ${endX} ${endY}`;

                path.setAttribute("d", d);
                path.setAttribute("fill", "none");
                path.setAttribute("stroke", CONFIG.colors.hidden);
                path.setAttribute("stroke-width", "2");
                path.setAttribute("stroke-linecap", "round");
                path.setAttribute("stroke-linejoin", "round");
                group.appendChild(path);

                const label = document.createElementNS("http://www.w3.org/2000/svg", "text");
                label.setAttribute("x", layer.x + size / 2);
                label.setAttribute("y", layer.y - 10);
                label.setAttribute("text-anchor", "middle");
                label.setAttribute("font-size", "12");
                label.setAttribute("font-weight", "600");
                label.setAttribute("fill", CONFIG.colors.hidden);
                label.textContent = "ReLU";
                group.appendChild(label);
            }

            drawConnections() {
                this.connectionsGroup.innerHTML = '';

                // Logic: Connect Linear -> Linear directly, skipping ReLU for connection lines
                // Filter only Node-containing layers
                const nodeLayers = LAYERS.filter(l => l.type !== 'ReLU');

                for (let i = 0; i < nodeLayers.length - 1; i++) {
                    const source = nodeLayers[i];
                    const target = nodeLayers[i + 1];

                    const sourceNodes = this.nodePositions[source.id];
                    const targetNodes = this.nodePositions[target.id];

                    // Fully connected mesh
                    // FIX: Use forEach with the actual node object which contains the correct 'index'
                    sourceNodes.forEach((sNode) => {
                        targetNodes.forEach((tNode) => {
                            // Determine control points for bezier.
                            const x1 = sNode.x + (CONFIG.cardWidth / 2); // Right edge of source node
                            const y1 = sNode.y;
                            const x2 = tNode.x - (CONFIG.cardWidth / 2); // Left edge of target node
                            const y2 = tNode.y;

                            const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
                            const controlDist = (x2 - x1) * 0.5;
                            const d = `M ${x1} ${y1} C ${x1 + controlDist} ${y1}, ${x2 - controlDist} ${y2}, ${x2} ${y2}`;

                            path.setAttribute("d", d);
                            path.setAttribute("fill", "none");
                            path.setAttribute("stroke", CONFIG.colors.connection);
                            path.setAttribute("stroke-width", "0.5"); // Thinner lines for dense mesh
                            path.setAttribute("stroke-opacity", "0.6");
                            // Add classes for easier selection during hover
                            // FIX: Use sNode.index and tNode.index instead of loop indices to match visual nodes (handling ellipsis)
                            path.setAttribute("class", `connection-path from-${source.id}-node-${sNode.index} to-${target.id}-node-${tNode.index}`);

                            this.connectionsGroup.appendChild(path);
                        });
                    });
                }
            }

            highlightNodeConnections(layerId, visualIndex) {
                // 1. Fade everything
                document.querySelectorAll('.connection-path').forEach(el => el.classList.add('faded'));

                // 2. Highlight incoming connections to this node
                // The class is `to-{layerId}-node-{visualIndex}`
                const incomingSelector = `.to-${layerId}-node-${visualIndex}`;
                document.querySelectorAll(incomingSelector).forEach(el => {
                    el.classList.remove('faded');
                    el.classList.add('highlighted');
                });

                // Update info panel
                const layer = LAYERS.find(l => l.id === layerId);
                const detailsDiv = document.getElementById('details-content');
                detailsDiv.innerHTML = `
                <div style="font-size:16px; font-weight:700; color:var(--text-heading); margin-bottom:10px;">
                    Neuron #${visualIndex + 1} in ${layer.name}
                </div>
                <p style="margin:5px 0; color:var(--text-body);">
                    Receives input from <strong>all</strong> ${layer.prevNodes || 0} nodes in the previous layer.
                </p>
                <p style="font-size:12px; color:var(--text-muted);">
                    Highlighted lines show the weighted inputs contributing to this neuron's value before activation.
                </p>
            `;
            }

            resetHighlights() {
                document.querySelectorAll('.connection-path').forEach(el => {
                    el.classList.remove('faded');
                    el.classList.remove('highlighted');
                });
                // Reset info text
                document.getElementById('details-content').innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Hover over a node to see incoming connections, or a layer card for details.</p>';
            }

            highlightLayer(layer) {
                // Update UI
                document.querySelectorAll('.layer-card').forEach(el => el.classList.remove('active'));
                document.getElementById(`card-${layer.id}`).classList.add('active');

                // Update Info Panel
                const detailsDiv = document.getElementById('details-content');
                const codeDiv = document.getElementById('code-content');

                // Badge HTML
                const badgeHtml = `<span class="badge ${layer.badgeClass}">${layer.type}</span>`;

                let paramsHtml = '';
                if (layer.type === 'Linear') {
                    const pCount = this.calculateParams(layer.prevNodes, layer.nodes);
                    paramsHtml = `<div style="margin-top:10px; font-size:13px; color:var(--text-body);">
                    <strong>Parameters:</strong> ${pCount.toLocaleString()} <br>
                    <span style="font-size:11px">(${layer.prevNodes} inputs × ${layer.nodes} neurons) + ${layer.nodes} biases</span>
                </div>`;
                }

                detailsDiv.innerHTML = `
                <div style="font-size:18px; font-weight:700; color:var(--text-heading); margin-bottom:10px;">
                    ${layer.name} ${badgeHtml}
                </div>
                <p style="margin:5px 0; color:var(--text-body);">${layer.desc}</p>
                <div class="math-block"><span class="math-var">${layer.math}</span></div>
                ${paramsHtml}
            `;

                codeDiv.innerHTML = layer.code;
                codeDiv.style.borderColor = layer.color;
            }

            toggleParams(show) {
                this.showParams = show;
                this.drawLayers();
                // Re-drawing layers wipes the nodes, so we need to re-draw connections to attach to new coordinates
                this.drawConnections();
            }

            animateForwardPass() {
                if (this.isAnimating) return;
                this.isAnimating = true;
                this.animationLayer.innerHTML = '';

                // We want to animate along the paths.
                // Sequence of node layers: Input -> Layer1 -> Layer2 -> Output
                const nodeLayers = LAYERS.filter(l => l.type !== 'ReLU');
                const totalStages = nodeLayers.length - 1;
                const durationPerStage = 800;

                const runStage = (stageIndex) => {
                    if (stageIndex >= totalStages) {
                        this.isAnimating = false;
                        setTimeout(() => { this.animationLayer.innerHTML = ''; }, 500);
                        return;
                    }

                    const sourceLayer = nodeLayers[stageIndex];
                    const targetLayer = nodeLayers[stageIndex + 1];

                    // Highlight source card
                    this.highlightLayer(sourceLayer);

                    // Get connections between these two layers
                    // Selector: any path that has 'from-{sourceId}'
                    // Actually, strictly speaking we need paths that are 'from-{sourceId}' AND 'to-{targetId}'
                    // But our drawing logic guarantees the sequence.

                    // Let's pick a random subset of connections to animate to avoid browser lag with hundreds of particles
                    const sourceNodes = this.nodePositions[sourceLayer.id];
                    const targetNodes = this.nodePositions[targetLayer.id];

                    // Create ~15 particles per stage
                    for (let k = 0; k < 15; k++) {
                        const randS = Math.floor(Math.random() * sourceNodes.length);
                        const randT = Math.floor(Math.random() * targetNodes.length);

                        // FIX: Ensure we use the stored index (handling ellipsis skipping) 
                        // Note: sourceNodes contains objects like {x, y, index}. 
                        // So we must access the .index property for the selector.

                        const sNode = sourceNodes[randS];
                        const tNode = targetNodes[randT];

                        if (!sNode || !tNode) continue;

                        const selector = `.from-${sourceLayer.id}-node-${sNode.index}.to-${targetLayer.id}-node-${tNode.index}`;
                        const path = document.querySelector(selector);

                        if (path) {
                            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                            circle.setAttribute("r", 5);
                            circle.setAttribute("fill", CONFIG.colors.hidden);

                            const animateMotion = document.createElementNS("http://www.w3.org/2000/svg", "animateMotion");
                            animateMotion.setAttribute("dur", `${durationPerStage}ms`);
                            animateMotion.setAttribute("repeatCount", "1");
                            animateMotion.setAttribute("path", path.getAttribute("d"));
                            animateMotion.setAttribute("fill", "freeze");
                            animateMotion.setAttribute("calcMode", "spline"); // smooth
                            animateMotion.setAttribute("keySplines", "0.4 0 0.2 1"); // ease-in-out
                            animateMotion.setAttribute("keyTimes", "0;1");

                            animateMotion.onend = () => {
                                if (circle.parentNode) circle.parentNode.removeChild(circle);
                            };

                            circle.appendChild(animateMotion);
                            this.animationLayer.appendChild(circle);
                            animateMotion.beginElement();
                        }
                    }

                    setTimeout(() => {
                        runStage(stageIndex + 1);
                    }, durationPerStage);
                };

                runStage(0);
            }

            reset() {
                this.animationLayer.innerHTML = '';
                document.querySelectorAll('.layer-card').forEach(el => el.classList.remove('active'));
                this.resetHighlights();
                this.isAnimating = false;
            }
        }

        // --- Initialization ---
        const viz = new NetworkViz();

        // --- Event Listeners ---
        document.getElementById('show-params').addEventListener('change', (e) => {
            viz.toggleParams(e.target.checked);
        });

        document.getElementById('animate-btn').addEventListener('click', () => {
            viz.animateForwardPass();
        });

        document.getElementById('reset-btn').addEventListener('click', () => {
            viz.reset();
        });

    </script>
</body>

</html>